---
description: Configure Commit-Boost
---

# Configuration

Commit-Boost needs a configuration file detailing all the services that you want to run. Create a `cb-config.toml` and modify it depending on which modules you plan to run.

- For a full explanation of all the fields, check out [here](https://github.com/Commit-Boost/commit-boost-client/blob/main/config.example.toml).
- For some additional examples on config presets, check out [here](https://github.com/Commit-Boost/commit-boost-client/tree/main/configs).

## Minimal PBS setup on Holesky
```toml
chain = "Holesky"

[pbs]
port = 18550

[[relays]]
url = ""

[metrics]
enabled = true
```

You can find a list of MEV-Boost Holesky relays [here](https://www.coincashew.com/coins/overview-eth/mev-boost/mev-relay-list#holesky-testnet-relays).
After the sidecar is started, it will expose a port (`18550` in this example), that you need to point your CL to. This may be different depending on which CL you're running, check out [here](https://docs.flashbots.net/flashbots-mev-boost/getting-started/system-requirements#consensus-client-configuration-guides) for a list of configuration guides.

:::note
In this setup, the signer module will not be started.
:::

## Signer module

Commit-Boost supports both local and remote signers. The signer module is responsible for signing the transactions that other modules generates. Please note that only one signer at a time is allowed.

### Local signer

To start a local signer module, you need to include its parameters in the config file

```toml
[pbs]
...
with_signer = true

[signer]
port = 20000

[signer.local.loader]
format = "lighthouse"
keys_path = "/path/to/keys"
secrets_path = "/path/to.secrets"
```

We currently support Lighthouse, Prysm, Teku, Lodestar, and Nimbus's keystores so it's easier to load the keys. We're working on adding support for additional keystores. These are the expected file structures for each format:

<details>
  <summary>Lighthouse</summary>

  #### File structure:
  ```
  ├── keys
  │   ├── <PUBLIC_KEY_1>
  │   │   └── voting-keystore.json
  │   └── <PUBLIC_KEY_2>
  │       └── voting-keystore.json
  └── secrets
      ├── <PUBLIC_KEY_1>
      └── <PUBLIC_KEY_2>
  ```

  #### Config:
  ```toml
  [pbs]
  ...
  with_signer = true

  [signer]
  port = 20000

  [signer.local.loader]
  format = "lighthouse"
  keys_path = "keys"
  secrets_path = "secrets"
  ```
</details>

<details>
  <summary>Prysm</summary>

  #### File structure:
  ```
  ├── wallet
  │   └── direct
  │       └── accounts
  │           └──all-accounts.keystore.json
  └── secrets
      └── password.txt
  ```

  #### Config:
  ```toml
  [pbs]
  ...
  with_signer = true

  [signer]
  port = 20000

  [signer.local.loader]
  format = "prysm"
  keys_path = "wallet/direct/accounts/all-accounts.keystore.json"
  secrets_path = "secrets/password.txt"
  ```
</details>

<details>
  <summary>Teku</summary>

  #### File structure:
  ```
  ├── keys
  │   ├── <PUBLIC_KEY_1>.json
  │   └── <PUBLIC_KEY_2>.json
  └── secrets
      ├── <PUBLIC_KEY_1>.txt
      └── <PUBLIC_KEY_2>.txt
  ```

  #### Config:
  ```toml
  [pbs]
  ...
  with_signer = true

  [signer]
  port = 20000
  
  [signer.local.loader]
  format = "teku"
  keys_path = "keys"
  secrets_path = "secrets"
  ```
</details>

<details>
  <summary>Lodestar</summary>

  #### File structure:
  ```
  ├── keys
  │   ├── <PUBLIC_KEY_1>.json
  │   └── <PUBLIC_KEY_2>.json
  └── secrets
      └── password.txt
  ```

  #### Config:
  ```toml
  [pbs]
  ...
  with_signer = true

  [signer]
  port = 20000
  
  [signer.local.loader]
  format = "lodestar"
  keys_path = "keys"
  secrets_path = "secrets/password.txt"
  ```

  :::note
  All keys have the same password stored in `secrets/password.txt`
  :::
</details>

<details>
  <summary>Nimbus</summary>

  #### File structure:
  ```
  ├── keys
  │   ├── <PUBLIC_KEY_1>
  │   │   └── keystore.json
  │   └── <PUBLIC_KEY_2>
  │       └── keystore.json
  └── secrets
      ├── <PUBLIC_KEY_1>
      └── <PUBLIC_KEY_2>
  ```

  #### Config:
  ```toml
  [pbs]
  ...
  with_signer = true

  [signer]
  port = 20000

  [signer.local.loader]
  format = "nimbus"
  keys_path = "keys"
  secrets_path = "secrets"
  ```
</details>

### Proxy keys store

Proxy keys can be used to sign transactions with a different key than the one used to sign the block. Proxy keys are generated by the Signer module and authorized by the validator key. Each module have their own proxy keys, that can be BLS or ECDSA.

To persist proxy keys across restarts, you must enable the proxy store in the config file. There are 2 options for this:

<details>
  <summary>File</summary>

  The keys are stored in plain text in a file. This method is unsafe and should only be used for testing.

  #### File structure

  ```
  <proxy_dir>
  └── <MODULE_ID>
        └── bls
            ├── <PROXY_PUBKEY1>
            └── <PROXY_PUBKEY2>
  ```

  #### Configuration

  ```toml
  [signer.local.store]
  proxy_dir = "path/to/proxy_dir"
  ```

  Where each `<PROXY_PUBKEY>` file contains the following:
  ```json
  {
    "secret": "0x...",
    "delegation": {
      "message": {
        "delegator": "0x...",
        "proxy": "0x..."
      },
      "signature": "0x..."
    }
  }
  ```
</details>

<details>
  <summary>ERC2335</summary>

  The keys are stored in a ERC-2335 style keystore, along with a password. This way, you can safely share the keys directory as without the password they are useless.

  #### File structure

  ```
  ├── <keys_path>
  │   └── <CONSENSUS_PUBLIC_KEY>
  │       └── <MODULE_ID>
  │           ├── bls/
  │           │   ├── <PROXY_PUBLIC_KEY1>.json
  │           │   ├── <PROXY_PUBLIC_KEY1>.sig
  │           │   ├── <PROXY_PUBLIC_KEY2>.json
  │           │   └── <PROXY_PUBLIC_KEY2>.sig
  │           └── ecdsa/
  │               ├── <PROXY_PUBLIC_KEY3>.json
  │               └── <PROXY_PUBLIC_KEY3>.sig
  └── <secrets_path>
      └── <CONSENSUS_PUBLIC_KEY>
          └── <MODULE_ID>
              ├── bls/
              │   ├── <PROXY_PUBLIC_KEY1>
              │   └── <PROXY_PUBLIC_KEY2>
              └── ecdsa
                  └── <PROXY_PUBLIC_KEY3>
  ```

  #### Configuration

  ```toml
  [signer.local.store]
  keys_path = "path/to/keys"
  secrets_path = "path/to/secrets"
  ```

  Where the `<PROXY_PUBLIC_KEY>.json` files contain ERC-2335 keystore, the `<PROXY_PUBLIC_KEY>.sig` files contain the signature of the delegation, and `<PROXY_PUBLIC_KEY>` files contain the password to decrypt the keystores.
</details>

### Remote signer

You might choose to use an external service to sign the transactions. For now, two types of remote signers are supported: Web3Signer and Dirk.

#### Web3Signer

Web3Signer implements the same API as Commit-Boost, so there's no need to set up a Signer module. The parameters needed for the remote signer are:

```toml
[signer.remote]
url = "https://remote.signer.url"
```

#### Dirk

Dirk is a distributed key management system that can be used to sign transactions. In this case the Signer module is needed as an intermediary between the modules and Dirk. The following parameters are needed:

```toml
[signer.dirk]
cert_path = "/path/to/client.crt"
key_path = "/path/to/client.key"
secrets_path = "/path/to/secrets"
# Optional parameters
ca_cert_path = "/path/to/ca.crt"

# Add one entry like this for each host
[[signer.dirk.hosts]]
server_name = "localhost-1"
url = "https://localhost-1:8081"
wallets = ["SomeWallet", "DistributedWallet"]

[[signer.dirk.hosts]]
server_name = "localhost-2"
url = "https://localhost-2:8082"
wallets = ["AnotherWallet", "DistributedWallet"]
```

- `cert_path` and `key_path` are the paths to the client certificate and key used to authenticate with Dirk.
- `wallets` is a list of wallets from which the Signer module will load all accounts as consensus keys. Generated proxy keys will have format `<WALLET_NAME>/<ACCOUNT>/<MODULE_ID>/<UUID>`, so accounts found with that pattern will be ignored.
- `secrets_path` is the path to the folder containing the passwords of the generated proxy accounts, which will be stored in `<secrets_path>/<WALLET_NAME>/<ACCOUNT>/<MODULE_ID>/<UUID>.pass`.

Additionally, you can set a proxy store so that the delegation signatures for generated proxy keys are stored locally. As these signatures are not sensitive, the only supported store type is `File`:

```toml
[signer.dirk.store]
proxy_dir = "/path/to/proxy_dir"
```

Delegation signatures will be stored in files with the format `<proxy_dir>/delegations/<MODULE_ID>/<PROXY_KEY>.sig`.

A full example of a config file with Dirk can be found [here](https://github.com/Commit-Boost/commit-boost-client/blob/main/examples/configs/dirk_signer.toml).


## Custom module
We currently provide a test module that needs to be built locally. To build the module run:
```bash
just docker-build-test-modules
```
:::note
We use `just` as command runner. If you don't have it installed, either install it from https://github.com/casey/just or run the commands manually from the `justfile` at the root of the repo.
:::

This will create a Docker image called `test_da_commit` that periodically requests signatures from the validator, and a `test_builder_log` module that logs BuilderAPI events.

The `cb-config.toml` file needs to be updated as follows:
```toml
[pbs]
port = 18550

[[relays]]
url = ""

[signer]
port = 20000

[signer.loader]
format = "lighthouse"
keys_path = "/path/to/keys"
secrets_path = "/path/to.secrets"

[metrics]
enabled = true

[[modules]]
id = "DA_COMMIT"
type = "commit"
docker_image = "test_da_commit"
signing_id = "0x6a33a23ef26a4836979edff86c493a69b26ccf0b4a16491a815a13787657431b"
sleep_secs = 5

[[modules]]
id = "BUILDER_LOG"
type = "events"
docker_image = "test_builder_log"
```

A few things to note:
- We now added a `signer` section which will be used to create the Signer module.
- There is now a `[[modules]]` section which at a minimum needs to specify the module `id`, `type` and `docker_image`. For modules with type `commit`, which will be used to access the Signer service and request signatures for preconfs, you will also need to specify the module's unique `signing_id` (see [the propser commitment documentation](../developing/prop-commit-signing.md)). Additional parameters needed for the business logic of the module will also be here.

To learn more about developing modules, check out [here](/category/developing).


## Vouch
[Vouch](https://github.com/attestantio/vouch) is a multi-node validator client built by [Attestant](https://www.attestant.io/). Vouch is particular in that it also integrates an MEV-Boost client to interact with relays. The Commit-Boost PBS module is compatible with the Vouch `blockrelay` since it implements the same Builder-API as relays. For example, depending on your setup and preference, you may want to fetch headers from a given relay using Commit-Boost vs using the built-in Vouch `blockrelay`.

### Configuration
Get familiar on how to set up Vouch [here](https://github.com/attestantio/vouch/blob/master/docs/getting_started.md).

You can setup Commit-Boost with Vouch in two ways.
For simplicity, assume that in Vouch `blockrelay.listen-address: 127.0.0.0:19550` and in Commit-Boost `pbs.port = 18550`.

#### Beacon Node to Vouch
In this setup, the BN Builder-API endpoint will be pointing to the Vouch `blockrelay` (e.g. for Lighthouse you will need the flag `--builder=http://127.0.0.0:19550`).

Modify the `blockrelay.config` file to add Commit-Boost:
```json
"relays": {
    "http://127.0.0.0:18550": {}
}
```

#### Beacon Node to Commit-Boost
In this setup, the BN Builder-API endpoint will be pointing to the PBS module (e.g. for Lighthouse you will need the flag `--builder=http://127.0.0.0:18550`).

This will bypass the `blockrelay` entirely so make sure all relays are properly configured in the `[[relays]]` section.

:::note
This approach could also work if you have a multi-beacon-node setup, where some BNs fetch directly via Commit-Boost while others go through the `blockrelay`.
:::

### Notes
- It's up to you to decide which relays will be connected via Commit-Boost (`[[relays]]` section in the `toml` config) and which via Vouch (additional entries in the `relays` field). Remember that any rate-limit will be shared across the two sidecars, if running on the same machine.
- You may occasionally see a `timeout` error during registrations, especially if you're running a large number of validators in the same instance. This can resolve itself as registrations will be cleared later in the epoch when relays are less busy processing other registrations. Alternatively you can also adjust the `builderclient.timeout` option in `.vouch.yml`.

## Hot Reload

Commit-Boost supports hot-reloading the configuration file. This means that you can modify the `cb-config.toml` file and apply the changes without needing to restart the modules. To do this, you need to send a `POST` request to the `/reload` endpoint on each module you want to reload the configuration. In the case the module is running in a Docker container without the port exposed (like the signer), you can use the following command:

```bash
docker compose -f cb.docker-compose.yml exec cb_signer curl -X POST http://localhost:20000/reload
```

### Signer module reload

The signer module takes 2 optional parameters in the JSON body:

- `jwt_secrets`: a string with a comma-separated list of `<MODULE_ID>=<JWT_SECRET>` for all modules.
- `admin_secret`: a string with the secret for the signer admin JWT.

Parameters that are not provided will not be updated; they will be regenerated using their original on-disk data as though the signer service was being restarted. Note that any changes you made with calls to `/revoke_jwt` or `/reload` will be reverted, so make sure you provide any modifications again as part of this call.

### Notes

- The hot reload feature is available for PBS modules (both default and custom) and signer module.
- Changes related to listening hosts and ports will not been applied, as it requires the server to be restarted.
- If running in Docker containers, changes in `volumes` will not be applied, as it requires the container to be recreated. Be careful if changing a path to a local file as it may not be accessible from the container.
- Custom PBS modules may override the default behaviour of the hot reload feature to parse extra configuration fields. Check the [examples](https://github.com/Commit-Boost/commit-boost-client/blob/main/examples/status_api/src/main.rs) for more details.
- In case the reload fails (most likely because of some misconfigured option), the server will return a 500 error and the previous configuration will be kept.
